<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Why Rust Makes Sense for Pipeline CLIs | Alejandro Cabrera</title>

    <meta name="description" content="Python is the default language in VFX, but for CLI tools that need to ship as single binaries, Rust has real advantages. Here is what I learned building two pipeline tools in Rust.">
    <meta name="author" content="Alejandro Cabrera">
    <meta name="keywords" content="Rust, VFX, pipeline, CLI, package manager, USD">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Why Rust Makes Sense for Pipeline CLIs">
    <meta property="og:description" content="Python is the default language in VFX, but for CLI tools, Rust has real advantages.">
    <meta property="article:published_time" content="2026-01-07">
    <meta property="article:author" content="Alejandro Cabrera">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Why Rust Makes Sense for Pipeline CLIs">

    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="../components.css">
    <link rel="stylesheet" href="../portfolio.css">
    <link rel="stylesheet" href="../blog.css">
</head>
<body>

<div class="reading-progress" id="reading-progress"></div>

<div class="layout">
    <aside class="rail">
        <a href="../index.html" class="rail-logo">AC</a>
        <nav class="rail-nav">
            <a href="../index.html" class="rail-link" title="Home">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
                    <polyline points="9 22 9 12 15 12 15 22"/>
                </svg>
            </a>
            <a href="../index.html#blog" class="rail-link active" title="Blog">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 19l7-7 3 3-7 7-3-3z"/>
                    <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/>
                    <path d="M2 2l7.586 7.586"/>
                    <circle cx="11" cy="11" r="2"/>
                </svg>
            </a>
        </nav>
        <div class="rail-cryptic">記事</div>
    </aside>

    <main class="main">
        <article class="blog-article">
            <header class="article-header">
                <nav class="article-breadcrumb">
                    <a href="../index.html">Home</a>
                    <span>/</span>
                    <a href="../index.html#blog">Blog</a>
                    <span>/</span>
                    <span>Rust for Pipeline CLIs</span>
                </nav>

                <div class="article-meta-top">
                    <span class="badge badge-sand">Rust</span>
                    <span class="article-reading-time" id="reading-time">6 min read</span>
                </div>

                <h1 class="article-title">Why Rust Makes Sense for Pipeline CLIs</h1>

                <p class="article-subtitle">
                    Python is the default language in VFX, but for CLI tools that need to ship as single binaries, Rust has real advantages. Here is what I learned building two pipeline tools in Rust.
                </p>

                <div class="article-author">
                    <div class="avatar avatar-sm">
                        <span class="avatar-fallback">AC</span>
                    </div>
                    <div class="article-author-info">
                        <span class="article-author-name">Alejandro Cabrera</span>
                        <time class="article-date" datetime="2026-01-07">January 7, 2026</time>
                    </div>
                </div>
            </header>

            <nav class="article-toc" id="toc">
                <h4 class="toc-title">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                        <line x1="8" y1="6" x2="21" y2="6"/>
                        <line x1="8" y1="12" x2="21" y2="12"/>
                        <line x1="8" y1="18" x2="21" y2="18"/>
                        <line x1="3" y1="6" x2="3.01" y2="6"/>
                        <line x1="3" y1="12" x2="3.01" y2="12"/>
                        <line x1="3" y1="18" x2="3.01" y2="18"/>
                    </svg>
                    Contents
                </h4>
                <ul class="toc-list">
                    <li><a href="#the-python-problem" class="toc-link">Python CLI Pain Points</a></li>
                    <li><a href="#why-rust" class="toc-link">So Why Rust?</a></li>
                    <li><a href="#anvil" class="toc-link">Anvil: a Package Manager in Rust</a></li>
                    <li><a href="#usd-lint" class="toc-link">Parsing USD with pest</a></li>
                    <li><a href="#the-ecosystem" class="toc-link">crates That Do the Heavy Lifting</a></li>
                    <li><a href="#learning-curve" class="toc-link">It Took Me Three Months to Feel Productive</a></li>
                    <li><a href="#when-to-use-it" class="toc-link">Pick Your Spots</a></li>
                </ul>
            </nav>

            <div class="article-content" id="article-content">
                <section id="the-python-problem">
                    <p class="lead">
                        I love Python. I have been writing it professionally for six years in VFX. It is the glue language of every pipeline I have worked on. But when it comes to shipping standalone CLI tools, Python has a distribution problem that gets worse the more you think about it.
                    </p>

                    <p>
                        Picture this: you write a neat CLI tool that resolves package dependencies for your studio's pipeline. It works perfectly on your machine. Now you need to get it running on 50 artist workstations, the render farm, and a couple of CI machines. Some run CentOS 7, some run Rocky 9, a few are on macOS. Each machine might have a different Python version, different system packages, and different virtualenv setups.
                    </p>

                    <p>
                        You can freeze it with PyInstaller, but those bundles are 50MB+ and take a noticeable second or two to unpack and start. You can use conda environments, but now every machine needs conda. You can use Rez to manage the Python environment, but that is circular when the tool you are building is a package manager itself.
                    </p>

                    <p>
                        This is where Rust came in for me.
                    </p>
                </section>

                <section id="why-rust">
                    <h2>So Why Rust?</h2>

                    <p>
                        The pitch for Rust in this context is simple: you compile your tool once per platform and get a single static binary with zero runtime dependencies. Drop it in <code>/usr/local/bin</code> or a network share. It just runs. No interpreter, no virtual environment, no dependency conflicts.
                    </p>

                    <p>
                        Startup time is essentially instant. Where a Python CLI might take 300-500ms just to import its modules, a Rust binary is ready in under 10ms. That matters when your tool is invoked hundreds of times during a render farm job or as part of a build system.
                    </p>

                    <p>
                        I am not one of those people who thinks you should rewrite everything in Rust. Most pipeline tools should absolutely stay in Python because that is what the team knows and that is what integrates with DCCs. But for standalone CLIs that live outside the DCC, Rust is a strong choice.
                    </p>
                </section>

                <section id="anvil">
                    <h2>Anvil: a Package Manager in Rust</h2>

                    <p>
                        Anvil is a package manager I built as an alternative to Rez. The core problem it solves is dependency resolution: given a request for packages A, B, and C, figure out which versions are compatible and set up the environment. Rez does this in Python, and for a large studio with thousands of packages, resolution can take several seconds. Artists notice.
                    </p>

                    <p>
                        In Rust, the same resolution algorithm finishes in low milliseconds. The difference is not just the language speed. Rust's type system forced me to think about the data structures more carefully, and I ended up with a cleaner resolver that caches intermediate results more effectively.
                    </p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">Rust</span>
                            <button class="code-copy" data-copy="code-1" title="Copy code">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                                </svg>
                                <span>Copy</span>
                            </button>
                        </div>
                        <pre><code id="code-1">use clap::Parser;

#[derive(Parser)]
#[command(name = "anvil", about = "Fast package resolver")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(clap::Subcommand)]
enum Commands {
    /// Resolve package dependencies
    Resolve {
        /// Packages to resolve
        #[arg(required = true)]
        packages: Vec&lt;String&gt;,

        /// Search paths for package definitions
        #[arg(short, long)]
        search_path: Vec&lt;String&gt;,
    },
    /// List available packages
    List {
        #[arg(short, long)]
        search_path: Vec&lt;String&gt;,
    },
}</code></pre>
                    </div>

                    <p>
                        Clap gives you argument parsing with auto-generated help text, shell completions, and validation. The derive macro approach means your CLI definition is basically a struct, which is much cleaner than manually wiring up argparse subparsers in Python.
                    </p>
                </section>

                <section id="usd-lint">
                    <h2>Parsing USD with pest</h2>

                    <p>
                        The second tool I built in Rust is usd-lint, a linter for USD files. It parses <code>.usda</code> files and checks for common problems: missing defaultPrim, incorrect composition arc ordering, namespace issues, and other things that will silently break your pipeline.
                    </p>

                    <p>
                        For parsing, I used the <code>pest</code> crate, which lets you define a PEG grammar and generates a parser from it. Writing a USDA parser is not trivial, but pest makes it manageable. The grammar file reads almost like a formal specification of the format.
                    </p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">Rust (pest grammar)</span>
                            <button class="code-copy" data-copy="code-2" title="Copy code">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                                </svg>
                                <span>Copy</span>
                            </button>
                        </div>
                        <pre><code id="code-2">// Simplified excerpt from the pest grammar
prim_spec = {
    "def" ~ prim_type? ~ string_value ~ "{" ~ prim_body ~ "}"
}
attribute = {
    attr_variability? ~ attr_type ~ attr_name ~ "=" ~ attr_value
}
reference_arc = {
    "prepend"? ~ "references" ~ "=" ~ reference_list
}</code></pre>
                    </div>

                    <p>
                        One feature I am happy with is the <code>--format github</code> flag. It outputs lint warnings in the format that GitHub Actions understands, so warnings show up as inline annotations on pull requests. More on that in a future post about CI patterns.
                    </p>
                </section>

                <section id="the-ecosystem">
                    <h2>crates That Do the Heavy Lifting</h2>

                    <p>
                        Rust's crate ecosystem is genuinely good for CLI tooling. Besides clap and pest, I regularly use:
                    </p>

                    <ul>
                        <li><strong>serde</strong> for JSON/TOML serialization. Package manifests in Anvil are TOML files, and serde makes parsing them trivial.</li>
                        <li><strong>rayon</strong> for parallel iteration. Linting hundreds of USD files? Just swap <code>.iter()</code> for <code>.par_iter()</code> and it fans out across cores.</li>
                        <li><strong>anyhow</strong> for error handling. Propagating errors up the call chain is clean with the <code>?</code> operator.</li>
                        <li><strong>indicatif</strong> for progress bars. Because artists will think your tool is frozen if there is no feedback.</li>
                    </ul>

                    <p>
                        The compile times are the downside. A full build of Anvil takes about 45 seconds on my M2. Incremental builds are much faster, but if you are coming from Python where there is no compile step, it is noticeable.
                    </p>
                </section>

                <section id="learning-curve">
                    <h2>It Took Me Three Months to Feel Productive</h2>

                    <p>
                        I will be honest: the borrow checker was frustrating for the first few weeks. I kept trying to write Python-style code where you pass references around freely, and the compiler kept telling me no. It took a while to internalize that Rust's ownership model is not a limitation but a different way of thinking about data flow.
                    </p>

                    <p>
                        The moment it clicked for me was when I stopped fighting lifetimes and started designing my data structures around ownership from the start. Instead of passing mutable references to some shared state, I would structure things so each function owned its data and returned new values. It made the code clearer, not just for the compiler but for me reading it later.
                    </p>

                    <p>
                        If you are a Python developer considering Rust, my advice is to start with a small, self-contained project. A CLI tool is perfect because it has clear inputs and outputs. Do not start with anything that needs async networking or complex lifetimes. Build something you understand well in Python, then port it. You will learn faster when the problem domain is familiar.
                    </p>
                </section>

                <section id="when-to-use-it">
                    <h2>Pick Your Spots</h2>

                    <p>
                        To be clear about where I think Rust makes sense in VFX:
                    </p>

                    <ul>
                        <li>Standalone CLIs that need to run everywhere without setup</li>
                        <li>Tools that are called many times in tight loops (build systems, farm jobs)</li>
                        <li>Parsers and linters that process large files or many files at once</li>
                        <li>Anything where you want a single binary you can version and deploy trivially</li>
                    </ul>

                    <p>
                        Where Python is still better: anything inside a DCC, quick scripts, prototyping, tools that need to integrate with ShotGrid or other Python-only APIs, and anything where the team needs to maintain it and everyone knows Python.
                    </p>

                    <p>
                        The two languages complement each other well. I use PyO3 in my USD asset resolver to expose Rust functions to Python, so you do not even need to pick one or the other. You can write the performance-critical core in Rust and wrap it for Python consumption. But that is a topic for another post.
                    </p>
                </section>
            </div>

            <footer class="article-footer">
                <div class="article-tags">
                    <span class="article-tags-label">Topics:</span>
                    <a href="#" class="badge badge-secondary">Rust</a>
                    <a href="#" class="badge badge-secondary">VFX</a>
                    <a href="#" class="badge badge-secondary">CLI</a>
                    <a href="#" class="badge badge-secondary">Pipeline</a>
                </div>

                <div class="article-share">
                    <span class="article-share-label">Share:</span>
                    <button class="btn btn-ghost btn-sm share-btn" data-share="twitter" title="Share on Twitter">
                        <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
                    </button>
                    <button class="btn btn-ghost btn-sm share-btn" data-share="linkedin" title="Share on LinkedIn">
                        <svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
                    </button>
                    <button class="btn btn-ghost btn-sm share-btn" data-share="copy" title="Copy link">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                        </svg>
                    </button>
                </div>

                <div class="author-card">
                    <div class="avatar avatar-lg">
                        <span class="avatar-fallback">AC</span>
                    </div>
                    <div class="author-card-content">
                        <h4 class="author-card-name">Alejandro Cabrera</h4>
                        <p class="author-card-bio">
                            Pipeline TD and Software Developer based in Canada. Building tools for VFX pipelines and cloud infrastructure.
                        </p>
                        <div class="author-card-links">
                            <a href="https://twitter.com/tv01d" class="btn btn-sm btn-ghost">Twitter</a>
                            <a href="https://github.com/voidreamer" class="btn btn-sm btn-ghost">GitHub</a>
                        </div>
                    </div>
                </div>

                <nav class="article-nav">
                    <a href="cross-dcc-communication.html" class="article-nav-link article-nav-prev">
                        <span class="article-nav-label">Previous</span>
                        <span class="article-nav-title">Cross-DCC Communication in VFX: What Actually Works</span>
                    </a>
                    <a href="usd-production-pitfalls.html" class="article-nav-link article-nav-next">
                        <span class="article-nav-label">Next</span>
                        <span class="article-nav-title">USD Pitfalls I Hit in Production</span>
                    </a>
                </nav>
            </footer>
        </article>

        <footer class="p-footer">
            <div class="p-footer-left">
                <span class="cryptic-label">系統終端</span>
                <span>Built with care, 2026</span>
            </div>
            <div class="p-footer-right">
                <a href="https://twitter.com/tv01d">Twitter</a>
                <a href="https://github.com/voidreamer">GitHub</a>
            </div>
        </footer>
    </main>
</div>

<div class="toast" id="toast"></div>

<script src="../app.js"></script>
</body>
</html>